# Compliance Plan: agents.py vs System Design Principles

This plan catalogues the gaps between `ai_scientist/orchestrator/agents.py` and the guarantees listed in `docs/system_design_principles.md`, then incrementally brings the agents/orchestrator surface into alignment. Each value increment builds observable compliance, and every checklist item has a clear acceptance criterion so implementers can mark it done.

## Value Increment 1 – Artifact Metadata & Typed Artifact Enforcement
- [x] Capture the canonical metadata requirements (principles 4–6, 13–16) in a reference doc linked from the orchestrator and agent prompts. The doc should enumerate `id`, `type`, `version`, `parent_version`, `status`, `module`, `summary`, `content`, and `metadata` for every typed artifact mentioned in `_artifact_kind_catalog()` and explain parent relationships for updates. Acceptance: new markdown document under `docs/` or `ai_scientist/orchestrator/` referenced by both `agents.py` instructions and by the registry helpers (`docs/artifact_metadata_requirements.md` now fulfills the reference requirement).
- [x] Strengthen `reserve_typed_artifact`/`reserve_and_register_artifact` (the registry heavily invoked by every role in `build_team`) to validate the mandated metadata before reserving paths and to auto-fill defaults when missing (e.g., generating `version`/`parent_version`). Acceptance: helper validation now enriches or rejects metadata before path reservation, and manifest entries capture the normalized metadata (see `ai_scientist/orchestrator/artifacts.py` lines 260-330); invalid metadata returns descriptive errors.
- [x] Ensure every tool instruction inside `build_team` explicitly calls out the expectation that artifacts carry the documented metadata (e.g., “Use reserve_typed_artifact(..., meta_json={...}) with id/version/status”). Acceptance: each agent prompt (Archivist/Modeler/Analyst/Reviewer/Interpreter/Coder/Publisher) plus the PI instructions now append the metadata reminder before directives (see `ai_scientist/orchestrator/agents.py:198-558`), fulfilling the requirement.

## Value Increment 2 – Role-Specific Access & Context View Specifications
- [x] Define and persist a “context view spec” for each role (Archivist, Modeler, Analyst, Interpreter, Reviewer, Coder, Publisher, PI) as structured data that lists allowed artifact types, whether summaries/full content are provided, and hard `K` limits (principles 7–9, 20–23). Acceptance: `ai_scientist/orchestrator/context_specs.py` now holds specs, and all prompts reference each role’s spec text before directives.
- [x] Extend the orchestrator to enforce those specs at runtime by filtering the artifacts passed into the role agents. Acceptance: `list_artifacts` and `list_artifacts_by_kind` in `ai_scientist/orchestrator/tool_wrappers.py` truncate outputs to each role’s `max_artifacts` (logging contextual usage), and `reserve_typed_artifact`/`reserve_and_register_artifact` reject writes outside the declared `write_scope`.
- [x] Document the enforced read/write scopes per role within the same spec module so every prompt and tool call avoids “opt-outs” (principles 7–9). Acceptance: `context_specs` exposes `read_scope`/`write_scope` lists and `agents.py` now injects the formatted spec reminder before directives for every role.

## Value Increment 3 – Summaries & Compression Workflow
- [ ] Build a summarization workflow that triggers whenever a module exceeds a configured artifact threshold (principles 10–12). Acceptance: a new helper (e.g., `ai_scientist/orchestrator/summarization.py`) watches the manifest for new artifacts, auto-generates integrated memos, and writes them via typed artifacts before a cross-module task runs.
- [ ] Update `agents.py` instructions so prompts encourage consuming summaries (the path_guardrails already mention not using raw logs). Acceptance: each role’s instructions note “Use `summarize_artifact` first and only request full content when the spec demands it.”
- [ ] Automate “compression steps” by adding enforcement in the orchestrator runner: before PI delegates to another module, it must confirm the latest summary artifact exists and is marked `status=canonical`. Acceptance: the runner refuses to start new module-level work until the summarizer has emitted a summary artifact with no stale dependencies.

## Value Increment 4 – Versioning, Canonicality, and Change Tracking
- [ ] Introduce explicit versioning helpers for manifest entries so every artifact append operation records `parent_version` and `status`, and previous versions remain queryable (principles 13–16). Acceptance: manifest helper functions now require `parent_version`/`status` fields and `_artifact_kind_catalog()` documents canonical versions.
- [ ] Add “promotion” tooling or instructions (principle 18) so a PI action (or other governance step) marks artifacts canonical only after review. Acceptance: `agents.py` includes a `write_pi_notes` or `manage_project_knowledge` step that sets canonical status and logs the promotion; this is enforced by a new helper that flips a flag in the manifest.
- [ ] Record change descriptions/deltas when major artifacts update (principle 15). Acceptance: `append_manifest` calls now store a short `change_summary` field and versions can be diffed via `read_manifest_entry` showing “what changed” metadata.

## Value Increment 5 – Observability, Async Safety, and Lifecycle Guardrails
- [ ] Log every agent invocation’s context inputs and produced artifacts to satisfy traceability (principles 30–31). Acceptance: each `build_team` call writes a `status_<role>` JSON (if not already doing so) that lists artifact IDs/versions read and written; the PI can inspect them via `inspect_manifest` or `read_status` helper.
- [ ] Implement dependency staleness detection so downstream artifacts flagged as canonical are checked against their inputs’ versions (principles 17, 19, 26). Acceptance: a new validation step runs before publishing/finalizing, marking artifacts `needs_update` when any referenced input has a newer version.
- [ ] Define a “spine” of canonical artifacts (project_brief, module integrated memos, project summary) and ensure unused drafts are deprecated after a period (principles 2, 27–29). Acceptance: a scheduled check (manual script or orchestrator step) marks stale drafts as `status=deprecated` and logs the action; the spine artifacts remain accessible via a `current_spine.json` typed artifact.
- [ ] Provide a summary snapshot generator for human-understandable state (principle 32). Acceptance: run a summary writer under `ai_scientist/orchestrator/snapshots.py` that compiles question/hypotheses/evidence from canonical artifacts and writes `experiment_results/project_snapshot.md` with references to the spine.

Each increment should be validated with manifest entries, tests, or inspectable artifacts before marking the checkbox done. This plan ensures that the orchestrator and agents surface align with the artefact-centric, role-scoped, versioned, and observable workflow defined in `system_design_principles.md`.
